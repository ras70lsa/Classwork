\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[latin1]{inputenc}
\usepackage{amsthm}
\usepackage{varwidth}
\usepackage{verbatim}

\newenvironment{centerverbatim}{%
  \par
  \centering
  \varwidth{\linewidth}%
  \verbatim
}{%
  \endverbatim
  \endvarwidth
  \par
}


\title{HW \#2 - Problem 3}
\author{Ryan St.Pierre (ras70)}
\date{\today}

\begin{document}
\maketitle
\pagebreak

\noindent
\textbf{Problem 3A}
\vspace{4mm}

\noindent
\textit{State}
\vspace{2mm}

Let $a[i]$ be the maximum possible value generated by an expression containing + and x between the indices from items 1 to i in the list (where item 1 corresponds to the zero-th index of the input array).

\vspace{2mm}
\noindent
\textit{Transition Function}
\vspace{2mm}

Let $b[1...n]$ be the array of integers given. We need a representation to cleanly define this product from the last + to a given index in the list. To do this let's define $S_{k,t}$, such that,

$$S_{k,h} = \prod_{x=k}^{h} b[x]\text{  *}$$

\noindent
*assuming that $b$ is one (not zero) indexed.
\vspace{2mm}

From this definition of $S_{k,t}$ it must follow that $S_{i,i}$ is simply b[i]. This will be helpful in defining our transition function below:

\vspace{3mm}
$$a[i] = \text{Max}_{d: 1\text{ to }i-1}(a[d] + S_{d+1, i})$$
\vspace{3mm}

\noindent
\textit{Base Cases}
\vspace{2mm}

Again let $b[1...n]$ be the array of integers given.

$$a[1]=b[0]$$

This base case says that the maximum expression that can be generated with the first item in the given array of integers is simply the value of the first item.

\vspace{2mm}
\noindent
\textit{Ordering}
\vspace{2mm}

From the transition function it is clear that to calculate $a[i]$ all values to the left of this in the DP array need to be calculated. Thus, the necessary ordering is $i$ in increasing value, starting at 1 and going to $n$.

\vspace{2mm}
\begin{centerverbatim}
i -> 1 to n
\end{centerverbatim}

\vspace{4mm}
\noindent
\textbf{Problem 3B}
\vspace{4mm}

\noindent
\textit{Algorithm}
\vspace{2mm}

\begin{enumerate}
  \item Calculate the transition function for all values from $i=1$ to $i=n$ by looping through the inputted value array. For discussion on ordering please reference Problem 3A. For clarity on how to calculate $S_{d+1, i}$ please reference the pseudo-code below.
  \item \textbf{Return } $a[n]$. This corresponds to the largest possible value of the expression using all $n$ elements in the inputted list of values.
\end{enumerate}

\noindent
Pseudo-code for the algorithm is given below:

\begin{verbatim}
int calculateLargestExpressionValue(b) {

    a[1] = b[0]
    n = length(b)

    for i = 2 to n
        currentMax = 0
        S = 1
        for j = i-1 to 1 {
            // set the index equal to i-1 to
            // be consistent with zero indexing
            index = j-1
            S = S * b[index]
            val = a[j] + S
            if val > currentMax
                currentMax = val
        }
        a[i] = currentMax


    return a[n]
}
\end{verbatim}

One area of note in the above algorithm is the bounds of the second \textit{for} loop,over the iterator $j$. I chose to go in descending order, from $i-1$ to 1. This allows me to maintain $S_{d,i}$ (the value of the product from items $d$ to $i$ as iterates over the possible values from $1$ to $i-1$). If I iterated in increasing order I would have had to calculate this $S_{d,i}$ term every time, making the running time less clear.

The comments regarding indexing in the pseudo-code above is also noteworthy. The transition function uses one-indexing. However, since this is not true for most programming languages I wanted to use zero indexing in the pseudo-code above. For this reason the conversion is necessary.

\vspace{4mm}
\noindent
\textit{DP table}
\vspace{2mm}

The DP table, $a$, is a 1D array that mimics the structure of the array of values given, $b$. In other words the 1D DP array is also of length n (where n is the length of the array of values given).

The values of the DP array are filled in from left to right (1 to n). The value at location i is calculated by taking the maximum value of $a[j] + \prod_{x=j+1}^{i} b[x]$ for all $1\leq j < i$.

The value to the problem is the value of the DP array at location n.

\vspace{4mm}
\noindent
\textit{Running time}
\vspace{2mm}

From the pseudo-code above it is clear that the running time is $O(n^2)$. To calculate each value in the DP table the solution to all sub-problems to the left need to be checked. Since there are $n$ items in the DP array the running time is $O(n^2)$.

It is important to note that the expression $S_{d+1, i}$ from the transition function is maintained as the sub-problems are checked in the pseudo-code. This avoids the need to calculate $S_{d+1, i}$ by looping through the values from $d+1$ to $i$, a non-constant operation. If this  $S_{d+1, i}$ value was calculated every time it would have an effect on the running time. However, since it is maintained in a constant fashion it can be ignored while evaluating the running time.

\end{document}
